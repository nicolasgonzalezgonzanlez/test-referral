/**
 * @desc Receive a client schema and transform to OP user registration format.
 * @param {object} client user client object.
 * @returns {object}.
 */
const clientParse = (client) => {
  const { document, phone } = client;

  //Get gender
  const { gender = '' } = document;

  let genderDesc = '';
  if (gender.toUpperCase() === 'M' || gender.toUpperCase() === 'F') {
    //Parse gender
    genderDesc = gender.toUpperCase() === 'M' ? 'MALE' : 'FEMALE';
  }

  return {
    user: {
      firstName: document.firstName || '',
      lastName: document.lastName || '',
      email: client.email || '',
      identificationNumber: document.number || '',
      phone: `${phone.country}${phone.number}`,
      birthDate: document.birthdate,
      emailVerified: 'true',
      phoneVerified: 'true',
      identificationIssuerNumber: document.fiscalNumber || '',
      identificationNumberType: {
        code: 'DNI',
      },
      identificationVerified: 'true',
      tributaryInfo: {
        tributaryIdentificationType: {
          code: 'CUIL',
        },
        tributaryIdentificationCode: document.cuil || '',
        tributaryCondition: {
          code: 'RI',
        },
      },
      externalIdentity: {
        identityProvider: 'Custom',
        identityId: client.client_id,
        applicationId: 'tecoFintechAud',
      },
      address:
        Object.keys(client.address).length > 0
          ? parseAddressUpdate(client.address)
          : {},
      gender: genderDesc,
    },
  };
};

/**
 * Receive a op account register format and extract the account,
 * @desc This only serves to transform the result to a specific format
 * @param {object} register account register response format.
 * @returns {object}.
 */
const responseParse = (registerObj) => {
  return {
    id: registerObj.id || '',
    userId: registerObj.userId || '',
    relation: registerObj.accountsRelations,
    fullResponse: {
      ...registerObj,
    },
  };
};

/**
 * @desc Receive a client schema and transform to OP user update format.
 * @param {object} client user client object.
 * @returns {object}.
 */
const parseClientUpdate = (client) => {
  const { document, phone, address } = client;

  let clientData = {},
    clientAddress = {};

  //The user id is required to be able to generate the whole process.
  clientData.userId = client.client_id;

  //I verify that the data that really undergoes modifications is sent, so as not to whiten fields that already have content
  !!document.firstName ? (clientData.firstName = document.firstName) : '';
  !!document.lastName ? (clientData.lastName = document.lastName) : '';
  !!document.number ? (clientData.identificationNumber = document.number) : '';
  !!client.email ? (clientData.userEmail = client.email) : '';
  !!phone && phone.country && phone.number
    ? (clientData.phone = `${phone.country}${phone.number}`)
    : '';

  //It is verified that address data is sent, if they do not come, nothing is sent
  clientData.address =
    Object.keys(address).length > 0 ? parseAddressUpdate(address) : {};

  return clientData;
};

/**
 * @desc Receive a customer address and transform to OP user address update format.
 * @param {object} body client address
 * @returns {object}
 */
const parseAddressUpdate = (body) => {
  const { data, provider } = body.ExternalGeolocationData;

  data.geometry.location_type = 'ROOFTOP';

  //Parse googlemap response format to op.
  const normalizedExternal = {
    provider: provider || 'GoogleMap',
    data: {
      results: [data || {}],
      status: 'OK',
    },
  };

  const address = {
    externalGeolocationData: normalizedExternal,
  };

  //Get additional data
  const { comment, department, floor } = body;

  //Add additional data
  if (comment) address.comments = comment;
  if (department) address.department = department;
  if (floor) address.floor = floor;

  return address;
};

module.exports = {
  clientParse,
  responseParse,
  parseClientUpdate,
  parseAddressUpdate,
};
